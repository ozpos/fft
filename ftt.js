// Connected Device Names generated by shell script.
let allConnected="28-3c01d075ece3\n28-3c01d075f437\n";
let oneConnected="28-3c01d075ece3\n";
let otherConnected="28-3c01d075f437\n";
let noneConnected="\n";
// Device reading from shell script.
let okReading = "4e 01 55 05 7f a5 81 66 78 : crc=78 YES\n4e 01 55 05 7f a5 81 66 78 t = 12345\n";
let badReading = "4e 01 55 05 7f a5 81 66 78 : crc=78 NO\n4e 01 55 05 7f a5 81 66 78 t = 54321\n";

// The app is required to read from each connected device in turn and persist data and stats after disconnection.
/*
for each previously captured device
    if not in connected devices
        update device.connectionStatus to // DISCONNECTED

for each 'connected device'
         if new
            create
         else
            update device.connectionStatus to // CONNECTED & save timestamp to device.status.lastUpdated
*/
// For list of devices
DS18B20({topic: "devices", payload: allConnected}); //  oneConnected/otherConnected/noneConnected
// For device read
DS18B20({topic: "read_next", payload: okReading});  //  badReading

function DS18B20 (msg) {
    // get last known devices and data from persistent flow storage.
    let ft = flow.get("Temperatures.DS18B20") || [];

    if (ft.length === 0 && msg.topic !== "devices")
        return;

    switch (msg.topic) {
        case "devices":
            let currentlyConnected = new Devices(msg.payload).devices;
            // Add new devices and update the connected state of existing devices.
            node.warn("devices - 0 currentlyConnected=" + JSON.stringify(currentlyConnected));

            // Iterate over last known list of devices to see
            // if they are currently connected..
            ft.forEach((name, index) => {
                node.warn("ft - name=" + JSON.stringify(name));

                if (currentlyConnected.filter(nameMatch).length === 0) {
                    // No longer connected
                    node.warn("ft dis");
                    name.connectionStatus = "DISCONNECTED";
                    node.warn("ft dis2 " + JSON.stringify(name));
                    let sta = ft[index].status;
                    sta.lastUpdated = new Date();
                    node.warn("devices - 0.1");
                }

                function nameMatch(device) {
                    //node.warn("nameMatch - device=" + JSON.stringify(device));
                    device.name == name
                }
            })
            node.warn("devices - 1");

            // Update the connectionStatus of existing devices
            // and create new ones.
            currentlyConnected.forEach((name) => {
                node.warn("devices - 1-name=" + JSON.stringify(name));
                let known = ft.filter(nameMatch);
                if (known.length === 0) {
                    node.warn("not found - 1");
                    ft.push(name);
                    flow.set("Temperatures.DS18B20", ft);
                } else {
                    node.warn("found  - 1=" + JSON.stringify(known));
                }

                function nameMatch(device) {
                    node.warn("nameMatch - device=" + JSON.stringify(device));
                    device.name == name
                }
            });

            node.warn("devices - 2");

            flow.set("Temperatures.DS18B20", ft);
            break;
        case "read_next":
            // TODO
            let deviceReading = Reading(msg.payload);

            break;
        default:
            break;
    }
    return;
}
function Reading(data){
    this.crc = fromData(data, 0);
    this.temperature = fromData(data,1);

    function fromData(data, idx){
        switch(idx){
            case 0:
                //look for 'YES' in 1st line of data
                return; // "YES/NO"
            case 1:
                //look fot 't = 12345' where 12345 is the temperature in 1/1000s.
                return; // "12345"
            default:
                break;
        }
    }
    return this;
}
// Return array of device objects
function Devices(data) {
    let devs = String(data).split("\n").filter(zeroLength);
    //let objs = devs.filter(zeroLength).map(name => ({ name }));    //arr.forEach((element, index) => {
    this.raw = data;                    //      obj[`key${index}`] = element;
    this.devices = [];                  //  });
    node.warn("data=" + data + " devices - 0.1 ");


    devs.forEach((name, index, array) => {
        node.warn("devices - 0.1.1");
        let dev = {[name]: {
                desc: "",
                name: name,
                rawData: data,
                status: {
                    crc: "",
                    crcOKCount: 0,
                    crcERRORCount: 0,
                    created: new Date(),
                    lastUpdated: new Date(),
                    previousOKUpdated: new Date(),
                    previousOKTemperature: null,
                    rawData: ""
                },
                connectionState: "CONNECTED", // CONNECTED/DISCONNECTED
                temperatureState: "UNKNOWN", // OK/ERROR/UNKNOWN
                temperature: null
            }};
        this.devices.push(dev);

    });
    return this;
}

function zeroLength(str) {
    return str.length > 0;
}
