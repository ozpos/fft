// Hi,
// found this https://duckduckgo.com/?q=intellij+nodered+external+editor%2Fdebugger&ia=web
// How to configure intellij idea as a node-red editor and debugger.
// TODO how to run here without node red ?
// node stubs.
function node_send(arr){

}
function node_warn(str){
    //console.warn(str);
}
let flow = {};
function flow_get(id){
    if (flow.hasOwnProperty(id))
        return flow[id];
}
function flow_set(id, data){
    if (flow.hasOwnProperty(id))
        flow[id] = data;
    else
        flow[id] = data;
}
// Connected Device Names generated by shell script.
let allConnected="28-3c01d075ece3\n28-3c01d075f437\n";
let oneConnected="28-3c01d075ece3\n";
let otherConnected="28-3c01d075f437\n";
let noneConnected="\n";
// Device reading from shell script.
let okReading = "4e 01 55 05 7f a5 81 66 78 : crc=78 YES\n4e 01 55 05 7f a5 81 66 78 t = 12345\n";
let badReading = "4e 01 55 05 7f a5 81 66 78 : crc=78 NO\n4e 01 55 05 7f a5 81 66 78 t = 54321\n";

// The app is required to read from each connected device in turn and persist data and stats after disconnection.
/*
for each previously captured device
    if not in connected devices
        update device.connectionState to // DISCONNECTED

for each 'connected device'
         if new
            create
         else
            update device.connectionState to // CONNECTED & save timestamp to device.status.lastUpdated
*/

// Example calls
// Lists of connected devices
DS18B20({topic: "devices", payload: allConnected}); //  oneConnected/otherConnected/noneConnected
// next line is not reached OK now.
DS18B20({topic: "devices", payload: oneConnected}); //  oneConnected/otherConnected/noneConnected
//DS18B20({topic: "devices", payload: otherConnected}); //  oneConnected/otherConnected/noneConnected
//DS18B20({topic: "devices", payload: noneConnected}); //  oneConnected/otherConnected/noneConnected
// For device read
DS18B20({topic: "read_next", payload: okReading});  //  okReading/badReading
//DS18B20({topic: "read_next", payload: badReading});  //  okReading/badReading

function DS18B20 (msg) {
    // get last known devices and data from persistent flow storage.
    let ft = flow_get("Temperatures.DS18B20") || [];
    let currentlyConnected = ft.filter(connected);
    let readNextDeviceIndex = flow_get("Temperatures.DS18B20_readNextDeviceName") || (ft.length > 0 ? 0 : -1);

    if (ft.length === 0 && msg.topic !== "devices")
        return;

    switch (msg.topic) {
        case "devices":
            // Here periodically to register connected devices and update old not now connected status.
            currentlyConnected = new Devices(msg.payload).devices;
            // Add new devices and update the connected state of existing devices.
            node_warn("devices - 0 currentlyConnected=" + JSON.stringify(currentlyConnected));

            // Iterate over last known list of devices to see
            // if they are currently connected..
            ft.forEach((name, index,arr) => {
                node_warn("ft - name=" + JSON.stringify(name));
//debugger
                if (currentlyConnected.filter(nameMatch).length === 0) {
                    // No longer connected
                    node_warn("ft dis");
                    name.connectionState = "DISCONNECTED";
                    // FIXED TODO ERROR - name has the correct obj structure
                    // I can set name.connectionState
                    // but not name.status.lastUpdated
                    //{ "__enc__": true, "type": "error", "data": { "name": "TypeError", "message": "Cannot set properties of undefined (setting 'lastUpdated')", "stack": "TypeError: Cannot set properties of undefined (setting 'lastUpdated')\n    at Function node:d36d164207a7f518 [DS18B20]:47:33\n    at Array.forEach (<anonymous>)\n    at Function node:d36d164207a7f518 [DS18B20]:36:12\n    at Function node:d36d164207a7f518 [DS18B20]:421:3\n    at Script.runInContext (node:vm:149:12)\n    at processMessage (/usr/lib/node_modules/node-red/node_modules/@node-red/nodes/core/function/10-function.js:430:37)\n    at FunctionNode._inputCallback (/usr/lib/node_modules/node-red/node_modules/@node-red/nodes/core/function/10-function.js:348:17)\n    at /usr/lib/node_modules/node-red/node_modules/@node-red/runtime/lib/nodes/Node.js:214:26\n    at Object.trigger (/usr/lib/node_modules/node-red/node_modules/@node-red/util/lib/hooks.js:166:13)" } }
                    node_warn("ft dis2 " + JSON.stringify(name));
                    //(arr[index]).status.lastUpdated = new Date();
                    name[Object.keys(name)[0]].status.lastUpdated = new Date();
                    node_warn("devices - 0.1");
                }

                function nameMatch(device) {
                    node_warn("nameMatch - device=" + JSON.stringify(device));
                    device[Object.keys(device)[0]].name === name.name;
                }
            })
            node_warn("devices - 1");

            // Update the connectionStatus of existing devices
            // and create new ones.
            currentlyConnected.forEach((name) => {
                node_warn("devices - 1-name=" + JSON.stringify(name));
                // calling the next line disappears up its own
                let known = ft.filter(nameMatch);
                if (known.length === 0) {
                    node_warn("not found - 1");
                    ft.push(name);
                    flow_set("Temperatures.DS18B20", ft);
                } else {
                    node_warn("found  - 1=" + JSON.stringify(known));
                }
                function nameMatch(device) {
                    node_warn("nameMatch - device=" + JSON.stringify(device));
                    device[Object.keys(device)[0]].name === name;
                }

            });

            node_warn("devices - 2");

            flow_set("Temperatures.DS18B20", ft);
            break;
        case "read_next":
            // Here with data as a result of a read on currentlyConnected[readNextDeviceIndex]
            // TODO - how to merge Reading into ft[index]
            if (readNextDeviceIndex > 0 && currentlyConnected.length > 0) {
                ft[readNextDeviceIndex] = new Reading(msg.payload);
                readNextDeviceIndex++;
                if (readNextDeviceIndex >= currentlyConnected.length)
                    readNextDeviceIndex = 0;
            } else {
                readNextDeviceIndex = currentlyConnected.length - 1;
            }
            flow_set("temperatures.DS18B20_readDeviceIndex", readNextDeviceIndex);
            if (readNextDeviceIndex >= 0)
                // TODO schedule  an os command to read device and trigger
                node_send([]);
            break;
        default:
            break;
    }

// Pushed from jetbrains IDE
    function Reading(data) {
        this.crc = fromData(data, 0);
        this.temperature = fromData(data, 1);

        function fromData(data, idx) {
            switch (idx) {
                case 0:
                    //look for 'YES' in 1st line of data
                    return data.indexOf("YES") > 0 ? "YES" : "NO"; // "YES/NO"
                case 1:
                    //look fot 't = 12345' where 12345 is the temperature in 1/1000s.
                    let t = data.split("t = ");
                    return t[1].split("\n")[0];
                default:
                    break;
            }
        }

        return this;
    }

// Return array of device objects
    function Devices(data) {
        let devs = String(data).split("\n").filter(zeroLength);
        //let objs = devs.filter(zeroLength).map(name => ({ name }));    //arr.forEach((element, index) => {
        this.devices = [];                  //  });
        node_warn("data=" + data + " devices - 0.1 ");


        devs.forEach((name) => {
            node_warn("devices - 0.1.1");
            let dev = {
                [name]: {
                    desc: "",
                    name: name,
                    rawData: data,
                    status: {
                        crc: "",
                        crcOKCount: 0,
                        crcERRORCount: 0,
                        created: new Date(),
                        lastUpdated: new Date(),
                        previousOKUpdated: new Date(),
                        previousOKTemperature: null,
                        rawData: ""
                    },
                    connectionState: "CONNECTED", // CONNECTED/DISCONNECTED
                    temperatureState: "UNKNOWN", // OK/ERROR/UNKNOWN
                    temperature: null
                }
            };
            this.devices.push(dev);

        });
        return this;
    }

    function zeroLength(str) {
        return str.length > 0;
    }

    function connected(dev) {
        return dev[Object.keys(dev)[0]].connectionState === "CONNECTED";
    }
}
